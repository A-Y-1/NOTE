# CPU虚拟化

## 一.抽象：进程

### 1.进程

​		**进程的概念**

​		进程是运行中的程序。是操作系统提供的最基本的抽象。

​		**时分共享与空分共享**

​		时分共享：允许资源由一个实体使用一段时间，然后由另一个实体使用一段时间，从而实现资源的共享。

​		空分共享：资源在空间上被划分给希望使用它的人。例如磁盘是一个空分共享资源。

​		**进程的机器状态**

​		理解进程的构成，必须理解进程的机器状态，即机器的哪些部分对于执行该程序是重要的。

- 内存：指令以及需要读取和写入的数据都在内存中，因此进程可访问的内存（地址空间）是进程的一部分。
- 寄存器：许多指令都需要读取或更新寄存器，还有一些特殊的寄存器如程序计数器和栈帧指针等，都是进程的一部分。
- I/O信息：程序经常访问持久存储设备，包含当前打开的文件列表在内的I/O信息也是进程的一部分。

### 2.进程API

- 创建：操作系统必须提供创建新进程的接口。
- 销毁：操作系统提供强制销毁进程的接口。
- 等待：有时需要等待进程停止运行，因此操作系统通常也提供某种等待接口。
- 其他控制：除了杀死或等待进程外，还可能有其他控制接口（暂停进程等）。
- 状态：返回进程状态的接口。

### 3.进程创建

​		操作系统将程序转化为进程，即创建进程，主要需要进行以下工作：

​		首先，操作系统需要将代码和所有静态数据加载到内存中，加载到进程的地址空间中。早期操作系统尽早完成加载，而现代操作系统惰性的完成加载，只有程序执行期间需要加载的代码和数据才会加载。

​		代码和静态数据加载到内存后，操作系统还需要为程序的运行时栈分配一些内存，也可能用参数初始化栈。操作系统也可能为堆分配一些内存，用于显式请求的动态分配数据。

​		操作系统还会执行一些其他初始化工作，特别是与输入输出相关的工作。完成所有初始化工作后，就可以跳转到程序入口，将控制权转移给新创建的进程，开始执行程序。

### 4.进程状态

​		进程可能处于以下三种状态：

- 运行：正在执行指令
- 就绪：进程准备好运行但未运行
- 阻塞：由于IO请求等事件而阻塞

## 二.进程API

### 1.fork()系统调用

​		UNIX系统中，使用fork()系统调用创建新进程。fork()将创建一个与原进程几乎完全相同的进程。调用fork()后，原进程和新进程都从fork()返回，原进程返回的值是新进程的PID，新进程返回0。而原进程与新进程的执行顺序是不确定的，这与调度有关。

### 2.wait()系统调用

​		使用wait()系统调用，可以让当前进程暂停执行，直到当前进程的一个子进程执行完毕。一般情况下，子进程运行结束，wait()调用才会返回。有些情况下，wait()会在子进程退出前返回。

### 3.exec()系统调用

​		exec()系统调用可以用于执行一个与原进程不同的新进程。给定可执行程序名称和参数，exec()会加载代码和静态数据，重新完成进程创建时的初始化工作，将当前程序替换为不同的程序，而exec()将永远不会返回。

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<sys/wait.h>

int main(int argc, char *argv[]){
    printf("Hello world (pid:%d)\n", (int)getpid());
    int rc=fork();										//fork()系统调用
    if(rc<0){
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if(rc==0){
        printf("Hello, I am child (pid:%d)\n", (int)getpid());
        char *args[3];
        args[0]=strdup("wc");
        args[1]=strdup("p3.c");
        args[2]=NULL;
        execvp(args[0], args);							//exec()系统调用
    }
    else{
        int wc=wait(NULL);								//wait()系统调用
        printf("Hello, I am parent (pid:%d)\n", (int)getpid());
    }
}
```

### 4.shell

​		fork()与exec()分离的机制非常有用。以shell为例，shell首先显示一个提示符，等待用户输入。用户可以输入可执行程序名及参数，shell可以找到这个程序，fork()创建新的进程，并调用exec()执行这个程序，调用wait()等待完成，子进程完成后，shell再次输出提示符，等待下一条命令。

## 三.机制：受限直接执行

​		虚拟化CPU存在两个重要挑战。第一个是<u>性能</u>，操作系统需要使用尽可能小的开销实现虚拟化。第二个是<u>控制权</u>，操作系统负责资源管理，必须保持控制权。在保持控制权的同时获得高性能，是操作系统的主要挑战。

### 1.受限直接执行（LDE）

​		为了使程序尽快运行，直接在CPU上运行程序，完成后返回操作系统。直接执行程序的问题有两个，一是如何保证程序不进行非法的操作，二是如何停下一个进程并切换到另一个进程，从而实现时分共享。

​		**受限制的操作**

​		进程需要能够执行受限制的操作，但又不能控制操作系统，因此，处理器采用的方法是引入新的模式：<u>用户模式</u>。进程在用户模式下运行，不能发出I/O请求或执行特权指令，而操作系统在<u>内核模式</u>运行，不受任何限制。

​		**系统调用**

​		为了使用户程序能够完成特权操作，硬件提供了用户程序执行系统调用的能力。

​		程序通过特殊的陷阱指令执行系统调用。陷阱指令跳入内核，提升特权级到内核模式，完成需要执行的特权操作。完成后，操作系统通过从陷阱返回的指令回到用户程序，同时降低特权级回到用户模式。进入陷阱时，硬件需要保存程序计数器和其他寄存器的值到进程的内核栈，从陷阱返回时再恢复这些值。

​		**陷阱表**

​		操作系统在启动时，会告诉硬件在异常时运行哪些代码，即设置陷阱表。当外部中断或系统调用发生时，硬件就知道此时该执行哪些程序。

​		**LDE协议**

​		LDE协议有两个阶段，第一个是在启动时，操作系统初始化陷阱表以供以后使用。第二个是运行进程时，操作系统完成分配内存等工作后，将CPU切换到用户模式开始运行进程。如果进程在运行时发出系统调用，就通过陷阱指令陷入操作系统，让操作系统完成需要完成的特权操作。

### 2.进程切换

​		**重新获取控制权**

​		进程是否切换由操作系统决定，且切换需要操作系统实现，因此操作系统需要在进程运行时能够重新获取控制权。获取方式为<u>协作方式与非协作方式</u>。其中非协作方式是通过<u>时钟中断</u>实现的，时钟设备每隔一段时间产生一次中断，操作系统的中断服务例程将会运行，操作系统从而重新获得控制权。时钟中断时，硬件需要保存进程的各种寄存器值到内核栈，返回进程时恢复这些寄存器值。

​		**保存和恢复上下文**

​		进程切换时需要进行上下文的切换，将当前进程的寄存器值保存，然后切换另一个进程的内核栈，恢复另一个进程的寄存器，这样完成上下文的切换，从陷阱返回时，运行的进程也切换了。

​		在LDE协议中，有两种类型的寄存器保存与恢复。第一种是时钟中断时，进程寄存器由<font color="red">硬件隐式保存到进程内核栈</font>。第二种是操作系统决定进行进程切换时，内核寄存器被<font color="red">操作系统明确保存到进程结构中</font>。

| **操作系统启动**                                             | 硬件                                                         |           |
| ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
| 初始化陷阱表                                                 |                                                              |           |
|                                                              | 记住系统调用处理程序，时钟处理程序的地址                     |           |
| 启动中断时钟                                                 |                                                              |           |
|                                                              | 启动时钟，定时中断                                           |           |
| 操作系统运行                                                 |                                                              | 进程创建  |
|                                                              |                                                              | 进程A运行 |
|                                                              | 时钟中断<br />将进程A的寄存器保存到A的内核栈<br />切换为内核模式<br />跳转执行陷阱处理程序 |           |
| 处理陷阱<br />调用switch()例程：<br />    将进程A的寄存器保存到A的进程结构<br />    从B的进程结构恢复寄存器<br />从陷阱返回 |                                                              |           |
|                                                              | 从B的内核栈恢复寄存器<br />切换为用户模式                    |           |
|                                                              |                                                              | 进程B运行 |



## 四.进程调度

### 1.调度指标

​		操作系统可以使用不同的调度策略，评价这些不同的调度策略有两个指标：

- 周转时间=完成时间-到达时间
- 响应时间=首次运行-到达时间

### 2.基本调度策略

​		**先进先出（FIFO）**

​		先进先出是最基本的调度算法，简单且易于实现。先到达系统的工作先运行。使用FIFO调度，如果每个任务的运行时间不同，则可能产生<u>护航效应</u>，即耗时较少的资源消费者排在重量级的资源消耗者之后。这种问题导致FIFO调度的周转时间表现很差。

​		**最短任务优先（SJF）**

​		为了解决FIFO中的护航问题，最短任务优先策略在调度时先运行需要时间最短的工作，然后是需要时间次短的工作。但如果工作在不同时间到达，需要时间长的工作先到达系统，短的工作后到达系统，仍然会产生护航效应。

​		**最短完成时间优先（STCF）**

​		最短完成时间优先策略在最短任务优先策略的基础上添加了抢占。每当新工作进入系统时，比较剩余工作和新工作中谁的剩余时间最少，调度运行该工作。

​		**轮转（RR）**

​		以上的相关方法在周转时间表现不同，在相应时间上都不是很好，而轮转调度解决了这个问题。在一个时间片内运行一个工作，然后切换到运行队列的另一个工作，反复执行，直到所有任务完成。但是工作切换需要上下文切换，这是需要成本的。此外，轮转调度的周转时间表现很差，这是提升响应时间表现的代价。

| 调度策略 | 是否抢占 | 响应时间 | 周转时间 | 是否导致饥饿 |
| -------- | -------- | -------- | -------- | ------------ |
| FIFO     | 否       | 差       | 一般     | 否           |
| SJF      | 否       | 差       | 较好     | 是           |
| STCF     | 是       | 差       | 好       | 是           |
| RR       | 是       | 好       | 差       | 否           |

### 3.多级反馈队列（MLFQ）

​		基本调度策略的一个重大问题在于，操作系统并不知道每个工作所需要的时间。多级反馈队列调度通过进程运行的情况做出工作所需时间的预测，从而解决这个问题。MLFQ有许多不同优先级的队列，总是优先执行高优先级的工作，如果工作在同一个优先级，则采用轮转调度工作。同时对于经常放弃CPU等待I/O的交互型进程，MLFQ保持高优先级，CPU密集型的工作则降低其优先级。然而这样会导致CPU密集型工作饥饿，而且工作可以通过频繁放弃I/O的方式保持自己的优先级。为了解决这些问题，对MLFQ进行优化，优化后的规则如下：

- 如果A的优先级>B的优先级，先运行A
- 如果A的优先级=B的优先级，轮转运行A和B
- 工作进入系统时，放在最高优先级
- 每当工作用完其在某一层的时间配额，就降低其优先级（避免交互型进程独占CPU）
- 每经过一段时间，就将系统中所有工作重新加入最高优先级（避免饥饿）

### 4.比例份额调度

​		比例份额调度的目标是确保每个工作都获得一定比例的CPU时间，而不是优化周转时间和响应时间。最为简单的实现就是采用随机方法的彩票调度。

​		**随机方法的优势**

​		与其他决策方法相比，采用随机方法至少有三点优势

- 随即方法常常可以避免奇怪的边角情况
- 随机方法很轻量，几乎不需要记录任何状态
- 随机方法很快，只需要很快地产生随机数就可以完成决策

​		**彩票调度**

​		彩票调度使用彩票数表示进程占有资源的份额。例如进程A，B各有75，25张票，分别为0-74票，75-99票，调度程序只需要从0-99抽取一个数，就可以决定运行的程序。在该调度策略下，还有一些其他机制，比如进程可以有自己的彩票分配，彩票转让，彩票通胀等。

```pseudocode
//选择要调度的进程
int counter=0;
int winner=getrandom(0,totaltickets);
node_t *current=head;
while(current){
    counter=counter+current->tickets;
    if(counter>winner)	break;
    current=current->next;
}
//调度运行....
```

​		**步长调度**

​		利用随机性的调度实现简单，但不一定能产生正确的比例，而步长调度是一个确定的公平分配算法。步长调度中每个工作都有自己的步长，步长与票数成反比。例如三个工作票数为100,50,250，步长可以取100,200,400（票数*步长=10000），每次工作运行后会用步长更新行程值，需要调度时，选择目前行程值最小的工作调度运行。与彩票调度相比，由于需要全局状态（行程值）进行调度，步长调度很难处理新加入系统的工作，而彩票调度只需要更新总票数就可以了。

```pseudocode
current=remove_min(queue);
schedule(current);
current->pass+=current->stride;
insert(queue,current);
```

## 五.进程通信

#### 1.共享空间

​		使用该种通信方式，操作系统会提供一个**共享空间**可以被进程1,2互斥的访问。共享空间可以基于数据结构（如只有一个数组的共享空间）共享，也可以基于存储区共享。

#### 2.消息传递

​		如果操作系统提供了发送消息和接收消息的原语，进程就可以通过格式化消息进行通信。消息由消息头（包含发送进程的ID，接收进程的ID，消息类型等）和消息体构成。消息传递有两种方式，一种是直接传递，进程1给进程2发送消息只需要将消息挂到进程2的消息队列上；另一种是间接传递，进程1将消息放到一个中间实体上，等待进程2取走。

#### 3.管道通信

​		管道通信是通过连接读写进程的一个共享文件实现的。进程1发送消息，将消息写入文件，进程2再从文件中读取消息。管道通信有以下特点：

- 半双工通信，同一时间只能单向传输，进程需要互斥访问管道
- 管道写满后，写进程被阻塞
- 没有写满不允许读，没有读空不允许写
- 数据读出后就被管道删除，只能有一个进程读数据

