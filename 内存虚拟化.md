# 内存虚拟化

​		为了使进程在内存中存储信息收到保护，不会被另一个进程所影响，以及使操作系统更易使用，性能更高，操作系统需要将计算机的内存进行虚拟化。为此，操作系统提供了物理内存的抽象，称为**地址空间**。虚拟化内存主要有三个目标：

- 透明：操作系统实现虚拟内存的方式程序不可见
- 效率：虚拟化尽可能高效
- 保护：进程应受到保护，不受其他进程影响

​		为了实现以上目标，操作系统提供了许多机制与策略进行内存的虚拟化。

## 一.地址转换

​		虚拟化内存的一个通用技术为基于硬件的地址转换，简称地址转换。对于每次内存访问产生的虚拟地址，**硬件**将指令中的虚拟地址转换为数据实际存储的物理地址。同时操作系统也需要适时的介入，完成正确的地址转换。

### 1.动态（基于硬件）重定位

​		动态重定位需要CPU提供两个寄存器：基址寄存器和界限寄存器。进程中使用的都是虚拟地址，硬件将虚拟地址加上基址寄存器中的数据，得到真正的物理地址，同时界限寄存器会提供访问保护，确认物理地址在合法范围内。

### 2.硬件支持

​		为了支持动态重定位，硬件需要提供的支持如下：

- 特权模式：防止用户模式进程执行特权操作
- 基址和界限寄存器：支持地址转换
- 能够实现地址转换和检查界限
- 修改基址和界限寄存器的特权指令
- 注册异常处理程序的特权指令
- 能够触发异常

### 3.操作系统的支持

​		为了实现动态重定位，操作系统也要适时的介入，操作系统主要处理以下问题：

- 内存管理：在进程创建和终止时分配或回收地址空间
- 基址与界限管理：在上下文切换时需要正确的设置基址界限寄存器
- 提供异常处理程序：处理非法访问内存的进程

## 二.分段

​		动态重定位需要将进程的地址空间完整的加载到内存中，不够灵活，为了解决这个问题，出现了分段机制。分段机制中，地址空间不是完整的放在内存中，而是按段放到内存中，<u>每个段都有一对基址和界限寄存器</u>。

### 1.分段机制

​		硬件在地址转换时需要知道段内的偏移量，以及地址引用的段。**显式方式**为将虚拟地址的前几位用来标识段，后面的位表示偏移。**隐式方式**硬件通过地址产生方式来确定段，如程序计数器产生的地址在代码段，基于栈或基址指针的地址在栈段，其他地址在堆段。这样就可以使用对应该段的基址和界限寄存器来计算物理地址。需要注意的是<font color="red">栈</font>，栈是反向增长的，<u>计算偏移的时候需要减去段的最大地址</u>。

​		以下是一个16KB的地址空间的例子：

![image-20220515193149257](OS/分段-例.png)

​		这个地址空间的大小为16KB，需要14位来表示地址。由于有三个段，采用前两位选择段，每个段的大小为4KB（有一个段被浪费了），后12位就用来表示偏移，栈由于反向增长，偏移需要减去4KB。

### 2.操作系统支持

​		分段为操作系统带来了新的问题，操作系统需要确保段寄存器被正常设置，并管理物理内存的空闲空间。对于第一个问题，操作系统只需要在上下文切换的时候保存和恢复各个段寄存器。第二个问题的关键在于，新的地址空间被创建时会在物理内存中找到存放段的空间，但段的大小不一定相同，很快物理内存就会充满许多小的空闲空间，这种问题被称为**外部碎片**。

​		解决外部碎片的方式使紧凑物理内存，重新安排原有的段，得到大的连续的空闲空间，但这种方式成本很高。另一种是使用空闲列表管理算法，尽可能保留大的空闲块用于分配。不管采用哪一种方式，外部碎片都不可能完全消除。

## 三.分页

### 1.分页机制

​		为了处理分段使物理内存空间碎片化的问题，将地址空间分隔为固定大小的单元，每个单元为一页。地址空间的每一页都对应着物理内存中的一页。

<img src="OS/分页-映射.png" alt="image-20220515195353119" style="zoom:70%;" />

​		虚拟页到物理页的对应关系需要进行记录，以完成地址转换，操作系统使用**页表**来记录虚拟页到物理页的映射关系。<u>每个<font color="red">进程</font>都有自己的页表</u>。用分页的方式建立地址空间，需要有虚拟页号用于找到物理页，以及页内的偏移量。

<img src="OS/分页-地址转换.png" alt="image-20220515195948636" style="zoom:70%;" />

### 2.页表

​		页表记录虚拟页到物理页的映射关系，表中的每一项称为**页表项（PTE）**。页表项中除了记录了物理帧号（PFN）外，还有一些位如保护位，访问位，有效位，存在位等，用于地址空间的管理。

<img src="OS/PTE.png" alt="image-20220515201419565" style="zoom:80%;" />

​		页表的位置存放在页表基址寄存器当中。地址转换时，需要找到页表，以虚拟页号为索引找到对应的物理页帧号，还需要加上偏移量，才能找到正确的物理地址。显然，分页基址的地址转换很慢，同时页表占用的内存也很大。这两个问题必须解决。

## 四.快速地址转换（TLB）

### 1.TLB

​		为了解决分页机制实现虚拟内存的性能问题，需要硬件辅助。地址转换旁路缓冲存储器（TLB），即地址转换缓存解决了这个问题。对每次内存访问，先检查TLB中有没有期望的转换映射，如果命中就可以很快的完成地址转换，如果未命中则需要访问页表查找转换映射。

```c++
VPN = (VirtualAddress & VPN_MASK) >> SHIFT 
(Success, TlbEntry) = TLB_Lookup(VPN) 
if (Success == True) 									// TLB Hit 
	if (CanAccess(TlbEntry.ProtectBits) == True) 
		Offset = VirtualAddress & OFFSET_MASK 
		PhysAddr = (TlbEntry.PFN << SHIFT) | Offset 
		AccessMemory(PhysAddr) 
	else 
		RaiseException(PROTECTION_FAULT) 
else 													// TLB Miss 
	PTEAddr = PTBR + (VPN * sizeof(PTE)) 
	PTE = AccessMemory(PTEAddr)  
if (PTE.Valid == False) 
	RaiseException(SEGMENTATION_FAULT) 
else if (CanAccess(PTE.ProtectBits) == False) 
	RaiseException(PROTECTION_FAULT) 
else 
	TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) 
	RetryInstruction() 
```

​		TLB的性能通过命中率来体现。而命中率依赖于时间局部性与空间局部性。

- 时间局部性：最近访问过的指令或数据项可能很快会再次访问
- 空间局部性：程序访问某个数据后，可能很快会访问临近的数据

​		除了VPN与PFN，TLB中还有一些其他位，比如有效位，标识地址转化是否有效（<u>与页表项的有效位不同</u>），其他位还有保护位，脏位等。

### 2.TLB未命中的处理

​		TLB未命中的处理可能由硬件或软件进行处理。对于复杂指令集计算机，硬件来处理未命中，硬件知道页表的位置，找到正确的页表项，然后更新TLB，重试指令。例如x86就是**硬件管理TLB**，当前页表由CR3寄存器指出。精简指令集计算机使用**软件管理TLB**，未命中时，在陷阱处理程序中，会查找页表中的转换映射，然后使用特权指令更新TLB，从陷阱返回。软件处理TLB未命中有两个需要注意的问题，一个是陷阱需要返回到导致陷阱的指令进行重试，另一个是需要避免无限递归未命中（可以将TLB处理程序不映射，或者保留一些永久有效的映射给这些代码）。

### 3.上下文切换时对TLB的处理

​		进程切换时，原进程的TLB不可以继续使用，因此需要处理，一种是简单清除TLB，另一种是支持TLB共享。

​		TLB共享是通过在TLB中添加**地址标识符（ASID）**实现的，这样TLB就可以缓存不同进程的地址空间映射而不发生冲突。并且硬件也需要知道当前是哪个进程正在运行，以便进行地址转换，因此操作系统在上下文切换时，必须将某个特权寄存器设置为当前进程的 ASID。

<img src="OS/TLB-ASID.png" alt="image-20220515204756104" style="zoom: 80%;" />

### 4.TLB的替换

​		当TLB满，插入新项需要换出旧项时，需要选择一个合适的旧项换出，尽可能保持较高的命中率。有许多策略来进行替换项的选择，这与页替换选择是一样的。常见的有最近最少使用（LRU）策略，随机策略等。

## 五.减小页表

### 1.更大的页

​		减小页表的最简单方式就是使用更大的页。同样的地址空间，页越大，页数也就越少，页表项也越少，因此页表也能够减小。但大内存页会导致页内的浪费（**内部碎片**），因此实际上操作系统通常使用较小的页：4KB或8KB。

### 2.分段与分页结合

​		分段与分页结合的方式是为每个逻辑分段提供一个页表，分段使用的基址寄存器不再指向段，而是指向段的页表，界限寄存器则保存了段中最大有效页的值，这样就可以只保留有效页的页表项，未分配的页将其标记为无效，不需要占用页表空间。但这样的方式重新带来了分段不灵活的问题。

### 3.多级页表

​		多级页表机制将页表分成页大小的单元，如果整页的PTE都无效，就不分配该页的页表，引入**页目录**来记录页表的页是否有效。页目录由**页目录项（PDE）**组成，，PDE包含有效位，页帧号等。

​		多级页表是有成本的，TLB未命中时，需要从内存加载两次，才能获取正确的地址转换信息，且复杂性也更高。

​		多级页表下虚拟地址的处理，示例如下：

​		假设有一个16KB的地址空间，64字节的页。则这个地址空间需要14位来寻址。地址空间共有2^8页，这些页需要的页表空间为4*2^8即1KB，一个页只有64字节，因此存放页表需要16页，那么页目录的索引应该有4位，页表的索引有4位（一个页内存放64/4=16个页表项），最后的6位用于表示页内偏移。

![image-20220516232151457](CSAPP/多级页表VPN.png)

## 六.超越物理内存

### 1.交换空间

​		为了实现更大的地址空间方便程序使用，操作系统需要将没有被使用的地址空间使用硬盘存储起来，在硬盘上所留出的这部分用于移入和移出物理页的空间被称为**交换空间**。

### 2.机制

​		**存在位**

​		判断物理页是否在内存中的方法是使用页表项中的存在位，如果存在位为1，则该页存在于物理内存中，为0则发生了页错误，页错误处理程序将运行，将页换入内存中。

​		**页错误处理**

​		页错误处理程序会处理页错误。根据产生错误的错误码以及页表项，该程序会判断是否需要进行页的换入。当需要换入页时，首先需要分配页，该分配好的页帧用于存放换入页，如果内存已满，还需要使用页交换策略换出一些页。分配好了可用的物理帧就可以从硬盘读取页了，页的位置是用页表项的前几位来表示的，换入后，页表项将被重新设置为正确的映射。

​		**页换出**

​		在页换入时，如果没有可用的物理页，就会换出一些页。但其实操作系统可以提前预留出一小部分空间。为了保证这一小部分空闲空间，操作系统会设置**高水位线和低水位线**，内存空闲页少于低水位线时，负责释放内存的线程（交换守护进程/页守护进程）就会运行，释放内存直到有高水位线个空闲内存页，留出足够的空闲空间。

### 3.页替换策略

​		**最优替换策略**

​		最优替换策略为：替换内存中在最远将来才会被访问的页。最优策略是不可以实现的，但可以用于比较，判断可实现的页替换策略的效果。

​		**FIFO替换策略**

​		页在进入系统时放入队列，替换时就换出最早放入队列的页。FIFO的实现很简单，但效果明显要很差，因为FIFO完全没有判断页是否重要就进行换出。

​		**随机替换**

​		**LRU**

​		将最近最少使用的页换出。基于历史的数据判断换出哪一页，能够尽可能符合局部性，因此效果很好。

​		**近似LRU：时钟算法**

​		记录历史信息需要付出代价，因此我们希望能够尽可能的保证替换策略的效果，又不需要付出大的代价。实现一个近似的LRU是可行的，只需要为每个页提供一个使用位，当该页被引用时，硬件就将使用位设置为1，寻找替换页时，使用时钟指针指向某个页，如果使用位是0就可以选择，如果为1则将其置0，然后对下一页进行同样的判断，直至遍历完列表。考虑到将被修改的页写入硬盘需要付出代价，还可以同时考虑脏位（修改位），将使用位为0，修改位也为0的页优先换出。